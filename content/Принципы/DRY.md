## DRY — don’t repeat yourself / «не повторяйте себя»

Следование принципу программирования DRY позволяет добиться высокой сопровождаемости проекта, простоты внесения изменений и качественного тестирования.

Рассмотрим простой пример. Допустим, у нас есть некий магазин с товарами. На эти товары есть персональные скидки, и нам нужно написать функцию получения цены со скидкой. Мы посмотрели в прайс, узнали, что скидка составляет 10%, и быстро написали функцию:

```python
def get_price_with_discount(price):  
   return price * 0.9
```

Позже мы увидели, что для других товаров в другом приложении скидка равна 30%. Ну что ж, не проблема, напишем и здесь аналогичную функцию:

```python
def get_price_with_discount_2(price):  
   return price * 0.7
```

Таким образом, мы нарушим принцип DRY. И теперь каждый раз нужно будет писать новую функцию для разных скидок.

Первое, что мы обязаны будем сделать, — вспомнить о принципе DRY. Чтобы устранить нарушение, нам предстоит удалить все функции, кроме первой, а значение скидки поместить в аргументы функции:

```python
def get_price_with_discount(price, discount):  
   return price * (1 - discount)
```

Теперь у нас не будет множества однотипных функций, и мы сможем переиспользовать её в различных приложениях.

Если код не дублируется, для изменения логики достаточно внести исправления всего в одном месте. Кроме того, проще тестировать одну (пусть и более сложную) функцию, а не набор из десятков однотипных. Следование принципу DRY всегда приводит к декомпозиции сложных алгоритмов на простые функции. А декомпозиция сложных операций на более простые (и повторно используемые) значительно упрощает понимание программного кода. Повторное использование функций, вынесенных из сложных алгоритмов, позволяет сократить время разработки и тестирования новой функциональности.

Следование принципу DRY помогает создать модульную архитектуру приложения и приводит к чёткому разделению ответственности за бизнес-логику между программными классами. А это — залог сопровождаемой архитектуры.
