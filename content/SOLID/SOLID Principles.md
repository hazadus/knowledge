## SOLID

- [[Single Responsibility Principle (SRP)]]
- [[Open-Closed Principle (OCP)]]
- [[Liskov Substitution Principle (OCP)]]
- [[Interface Segregation Principle (ISP)]]
- [[Dependency Inversion Principle (DIP)]]

---- 
**SOLID** — аббревиатура пяти фундаментальных принципов разработки в парадигме ООП. Следование этим принципам позволяет строить на базе ООП масштабируемые и сопровождаемые программные продукты с понятной бизнес-логикой и уменьшает связанность между классами, модулями и функциями, что способствует повторному использованию кода.

Принципы SOLID были определены Робертом С. Мартином в его книге “Clean Code: A Handbook of Agile Software Craftsmanship”, опубликованной в 2008 году.

1. **Принцип единственной ответственности (Single Responsibility Principle — SRP)**

Каждый класс или модуль должен иметь только одну причину для изменения. Это означает, что класс должен быть ответственным только за одну часть функциональности в системе.

2. **Принцип открытости/закрытости (Open/Closed Principle — OCP)**

Программные сущности, такие как классы, модули и функции, должны быть открыты для расширения, но закрыты для модификации. Это означает, что новая функциональность должна добавляться без изменения существующего кода.

3. **Принцип подстановки Барбары Лисков (Liskov Substitution Principle — LSP)**

Объекты в программе должны быть заменяемыми своими наследниками без изменения корректности программы. Это означает, что классы-наследники должны быть взаимозаменяемыми со своими родительскими классами и не нарушать ожидаемого поведения.

4. **Принцип разделения интерфейса (Interface Segregation Principle — ISP)**

Клиенты не должны зависеть от интерфейсов, которые они не используют. Интерфейсы следует разделять на более маленькие и специфичные, чтобы клиенты могли реализовывать только те методы, которые им нужны.

5. **Принцип инверсии зависимостей (Dependency Inversion Principle — DIP)**

Модули верхнего уровня не должны зависеть от модулей нижнего. Оба уровня должны зависеть от абстракций. Это означает, что зависимости должны быть абстракциями, а не конкретными реализациями.

Зачем следовать принципам SOLID? Возьмём, к примеру, принцип открытости/закрытости, который устанавливает, что вы должны иметь возможность расширять поведение класса, не изменяя его. Почему изменить поведение класса, открыв его файл в редакторе и внеся некоторые изменения, — плохая практика? Или принцип инверсии зависимостей, который гласит, что необходимо зависеть от абстракций, а не от конкретных реализаций. Что не так в зависимостях от конкретных реализаций?

